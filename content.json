{"meta":{"title":"blog_songxue77","subtitle":"songxue77's IT Blog","description":"blog for songxue77","author":"XUESONG SHEN","url":"http://songxue77.github.io","root":"/"},"pages":[],"posts":[{"title":"python:crawler","slug":"python-crawler","date":"2020-08-04T11:43:33.000Z","updated":"2020-08-04T12:35:37.005Z","comments":true,"path":"2020/08/04/python-crawler/","link":"","permalink":"http://songxue77.github.io/2020/08/04/python-crawler/","excerpt":"","text":"python 크롤링","categories":[],"tags":[]},{"title":"php:basic_coding_style","slug":"php-basic-coding-style","date":"2020-08-03T10:38:19.000Z","updated":"2020-08-03T14:37:07.661Z","comments":true,"path":"2020/08/03/php-basic-coding-style/","link":"","permalink":"http://songxue77.github.io/2020/08/03/php-basic-coding-style/","excerpt":"","text":"프로그래머의 성장에 대해, 그리고 기본기나는 회사에서 PHP프로그래밍을 하고 있다. 비록 IT회사가 아니지만 어느 정도 규모가 있고 개발팀 규모도 작지 않은편이다. 하지만 개발 트렌드를 빨리 따라가지 못하는 점을 어쩔 수 없는 일인 것 같다. 워낙 개발팀 자체가 회사의 운영을 돕는 역할을 하고 있기 때문에 영향력도 크지 않은 편이다. 나는 각종 커뮤니티나 사이트를 돌아다니면서 최신 트랜드를 알아보고 적용해볼려고 노력하는데 그 이유는 내가 하고 있는 프로그래밍과 사람들이 말하고 있는 TDD, 페어 프로그래밍, 코드리뷰, 디자인패턴, 자료구조, 알고리즘 등등 개념과는 거리가 먼 감이 들어서 불안하기 때문이다. 요즘은 개발자 채용이라면 자료구조, 알고리즘에 관련된 테스트를 보는게 트랜드가 된 것 같고 경력기술서 하나로는 부족하고 포트폴리오 정도는 있어야 서류통과라도 할 수 있는 시대이지만 나는 이런 개념들과 거리가 멀다. 웹 개발을 해보면 알겠지만 자료구조, 알고리즘, 디자인패턴은 그렇게 필수적이지 않다. 적어도 내가 개발해본 Admin페이지, API시스템, 서비스 사이트 등등을 돌이켜보면, 그것보다 더 중요한 것은 오히려 개발의 속도, 요구사항에 대한 이해, 적은 오류였다. 왜냐면 PHP의 배열은 충분히 강력했고 또한 라라벨이 등장하면서 풀스텍 프레임워크로서 대부분 기능들을 쉽게 접근하도록 구현을 해놓았기에 개발자는 요구사항만 숙지하면 큰 어려움없이 개발할 수 있다. 내가 어떤 자료구조를 이용해서 어떻게 알고리즘을 짜냐보다 배열, 순환문, if문 등을 이용해서 해결할 수 있는 문제가 요구사항의 90%이상이다. 문제는 내가 점점 실증을 느끼기 시작한다는 것이다. 하루종일 속히 말하는 CRUD작업만 하고 있고 내가 개발자인지 웹 노가다를 하고 있는지 구분이 안간다고 생각을 할때도 있고 대용량 트래픽처리 로직같은 뭔가 ‘큰’프로젝트를 하지 못하니 자괴감이 든다는 데 있다. 이런 생각을 떨쳐버리지 못하면 고통의 무한순환에 빠지게 되고 지금의 일에 집중하기도 어렵고 내가 원하는지도 잘 파악이 되지 않아 이직도 쉽지 않다. 나는 이것저것 공부(머신러닝, 딥러닝, 프런트엔드 언어, 기타 백엔드 언어, 유닉스 프로그래밍, 네트워크)도 많이 해보았지만 결국 크게 견지할 수 있는게 없었다. 결국 현재 업무에 도움이 될 수 있는 지식을 배우는게 자기학습에 제일 큰 동기부여가 된다고 결론을 내린 것이다. 그럼 뭐부터 시작해볼까? 나는 기본기에 대해 말해보려 한다. 내가 말하려는 기본기는 자료구조나 알고리즘이 아닌 코드를 어떻게 조직해야 되는지이다. 내가 이때까지 자신감이 부족했던 이유는 내가 짠 코드를 잘 짰다고 생각하지 않았기 때문이다. 처음부터 회사에서 코드리뷰를 하고 멘토가 나의 코드를 케어해주는 방식이라면 좋겠지만 많은 사람들은 나처럼 회사에 입사해서 다른 사람의 코드를 보고 혼자서 배우고 성장을 한다. 근데 생각없이 그 상태로 지속해나가면 코드를 짜는데 기준이 없고 오류가 나는 코드를 많이 짜게 된다. 그럼 나같은 사람들은 어떻게 해야 할까? 코드의 짜임새부터 나만의 규칙을 가지고 그것을 끊임없이 보완해나가는게 중요하다고 생각한다. 아래와 같은 테이블에 데이터를 입력하거나 삭제해야 된다고 하면. UserIdx Password UserFavorite RegDatetime ModifyDatetime 12675 12345asdfg {“favoriteIdx”: [“7”, “8”,”9”]} 2020-07-26 00:18:09 2020-07-26 00:18:09 아래와 같은 코드를 짜게 될것이다. 라라벨을 쓰고 있다는 가정하에. 12345678910111213141516171819public function addFavorite($request)&#123; $userIdx = $request['user_idx']; $favoriteList = $request['list']; try &#123; // 1. 유저 데이터 조회 $userInfo = $this-&gt;userInfo-&gt;getUserInfo($userIdx); // 2. 즐겨찾기 존재하는지 체크 // 3. 있으면 업데이트 없으면 입력 &#125; catch (\\Exception $e) &#123; &#125; return $result;&#125; 해당 로직은 1) 해당 유저 데이터 조회 2) 즐겨찾기 항목 존재하는지 체크 3) 있으면 업데이트 하고 없으면 입력함 세개의 과정을 거치게 된다. 먼저 2)에서 즐겨찾기 존재하는지 체크할 때 123if ($userInfo-&gt;UserFavorite) &#123;&#125; 이렇게 체크해야 되지만 잘 생각해보았을 때 즐겨찾기는 추가할 수도 있고 삭제할 수도 있기 때문에 추가했다가 다시 모두 삭제했다면 db에는 UserIdx Password UserFavorite RegDatetime ModifyDatetime 12675 12345asdfg {“favoriteIdx”: []} 2020-07-26 00:18:09 2020-07-26 00:18:09 이런 상태가 되있을 것이다. UserFavorite컬럼의 상태는 null이거나 데이터가 입력되었다가 모두 삭제된 상태 {“groupIdx”: []}이거나 데이터가 존재하는 상태 {“groupIdx”: [“7”, “8”,”9”]} 세가지 가능성이 있다. 그러므로 새로운 입력인지 체크하기 위해서는 1234567891011121314if ($userInfo === null) &#123; // 처음 즐겨찾기 항목 입력 $userFavorite = []; foreach ($favoriteList as $item) &#123; $userFavorite[] = $item; &#125; $this-&gt;userInfo-&gt;where('UserIdx', $userIdx)-&gt;update([ 'UserFavorite' =&gt; json_encode(['favoriteIdx' =&gt; $userFavorite]) ]); &#125; else &#123; // 기존에 즐겨찾기 항목 있거나 비여있음&#125; 로 판단해서 예기치 못한 오류를 줄일 수 있다. 계속해서 기존에 데이터가 존재할 때의 경우를 짜보면 $favoriteList는 기존의 JSON에 중복값이 존재한다면 제거해야 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public function addFavorite($request)&#123; $connection = $this-&gt;startTransaction('mysql'); $userIdx = $request['user_idx']; $favoriteList = $request['list']; try &#123; // 1. 유저 데이터 조회 $userInfo = $this-&gt;userInfo-&gt;getUserInfo($userIdx); // 2. 즐겨찾기 존재하는지 체크 if ($userInfo === null) &#123; // 처음 즐겨찾기 항목 입력 $userFavorite = []; foreach ($favoriteList as $item) &#123; $userFavorite[] = $item; &#125; $this-&gt;userInfo-&gt;where('UserIdx', $userIdx)-&gt;update([ 'UserFavorite' =&gt; json_encode(['favoriteIdx' =&gt; $userFavorite]) ]); &#125; else &#123; // 3. 있으면 업데이트 없으면 입력 $userFavorite = $userInfo-&gt;UserFavorite; $userFavoriteData = json_decode($userFavorite, true); if ($userFavoriteData['favoriteIdx']) &#123; $userFavoriteNew = $userFavoriteData['favoriteIdx']; foreach ($favoriteList as $item) &#123; if (in_array($item, $userFavoriteData['favoriteIdx']) === false) &#123; $userFavoriteNew[] = $item; &#125; &#125; &#125; else &#123; $userFavoriteNew = []; foreach ($favoriteList as $item) &#123; $userFavoriteNew[] = $item; &#125; &#125; $this-&gt;userInfo-&gt;where('UserIdx', $userIdx)-&gt;update([ 'UserFavorite' =&gt; json_encode(['favoriteIdx' =&gt; $userFavoriteNew]) ]); &#125; $resultResponse = [ 'code' =&gt; '0000', 'message' =&gt; 'success', 'description' =&gt; 'update user favorite success' ]; $this-&gt;commitTransaction($connection); &#125; catch (\\Exception $e) &#123; $this-&gt;rollbackTransaction($connection); $resultResponse = [ 'code' =&gt; '9999', 'message' =&gt; 'fail', 'description' =&gt; $e-&gt;getMessage() ]; &#125; return response()-&gt;json( $resultResponse );&#125; 해당 로직을 완성하였다. 사실 미묘하게 나 자신도 마음에 들지 않지만 일단 나의 고민은 여기까지인 것 같다. 추후 좀 더 보완이 필요한 부분을 찾고 개선해나갈 예정이다.","categories":[],"tags":[]},{"title":"php로 제한 시간내에 많은 양의 데이터 처리하기","slug":"php-naver-power-link","date":"2020-07-31T12:53:53.000Z","updated":"2020-07-31T15:56:16.143Z","comments":true,"path":"2020/07/31/php-naver-power-link/","link":"","permalink":"http://songxue77.github.io/2020/07/31/php-naver-power-link/","excerpt":"","text":"1) 프로젝트 요구사항약 800개의 데이터가 DB에 저장되어 있는 상태 해당 데이터를 조회하고 API로 상태를 체크한 다음 상태값을 DB에 업데이트 3분마다 상태값 체크하고 DB에 입력필요 3분전의 데이터를 기반으로 상태값을 체크하기 때문에 3분안에 모든 데이터의 상태가 업데이트되어 있어야 함 2) 기술 스텍php7.2 (Laravel 6) MariaDB 3) 요구사항 분석하나의 데이터의 상태값을 업데이트 하기위해 API를 호출하는데 소모하는 시간은 0.8~1초 좌우 800개의 데이터를 순차적으로 업데이트하기에는 시간이 부족 동시 다중 처리가 필요 4) 구현1) 라라벨에 3분에 한번씩 실행하는 Cron로직 등록 123for ($i = 0; $i &lt; 800; $i += 100)&#123; $schedule-&gt;command('updateDataStatus', [$i, 100])-&gt;cron('*/3 * * * *')-&gt;runInBackground();&#125; 해당 로직에서 runInBackground()함수는 현재 프로세스에서 독립된 프로세스에서 실행되며 동시 처리가 가능 그말은 즉 해당 로직이 실행되면 8개의 프로세스가 각각의 파라미터를 가지고 실행됨 2) updateDataStatus라는 Command를 생성하며 전달 받은 [$i, 100]을 이용하여 데이터를 조회 만약 [0, 100]을 전달받았다면 DB조회 쿼리에서 LIMIT 0, 100으로 제한함으로 800개의 데이터를 한 프로세스당 100개씩 8개 프로세스에서 처리하게 됨 조회된 데이터를 기반으로 API를 호출하여 상태값 체크와 업데이트 실행 5) 결론php로 동시성 업무라면 먼저 떠오르는 것이 Laravel의 Queue기능을 이용해서 처리하는 것이지만 이렇게 Command만 이용해서 runInBackground함수를 사용해서 어느정도의 처리가 가능하다.","categories":[],"tags":[]},{"title":"php:mysql_pconnect","slug":"php-mysql-pconnect","date":"2020-07-30T11:34:16.000Z","updated":"2020-07-30T12:22:50.029Z","comments":true,"path":"2020/07/30/php-mysql-pconnect/","link":"","permalink":"http://songxue77.github.io/2020/07/30/php-mysql-pconnect/","excerpt":"","text":"mysql_pconnect()에 대한 고찰php는 mysql_connect 함수를 사용하여 mysql(mariadb)과 연결하고 통신을 합니다. 매번 php가 요청을 처리할 때마다 커넥션을 맺고 끊고를 반복합니다. 여기서 php5는 mysql_pconnect라는 함수를 제공하여 지속연결을 제공해준다고 합니다. (PHP 4, PHP 5) mysql_pconnect — Open a persistent connection to a MySQL server 커넥션을 맺고 끊고를 반복하지 않고 한번 맺은 커넥션으로 여러번의 요청을 처리할 수 있다고 하고 있습니다. 그러나 php는 스크립트형 언어로써 요청이 들어올때마다 실행되므로 여러번의 요청은 완전히 독립적입니다. 서로 독립적인 요청들이 하나의 커넥션 리소스를 어떻게 공유하는 것일까요? 또한 mysql_pconnect에 대한 평판도 그렇게 좋지 않은 것 같습니다. php.net의 mysql_pconnect함수 소개페이지에 들어가보면 사용을 추천하지 않는다는 건의가 많으며 심지어 php7에서는 삭제를 당합니다. Warning This extension was deprecated in PHP 5.5.0, and it was removed in PHP 7.0.0. Instead, the MySQLi or PDO_MySQL extension should be used. See also MySQL: choosing an API guide and related FAQ for more information. Alternatives to this function include: mysqli_connect() with p: host prefix PDO::__construct() with PDO::ATTR_PERSISTENT as a driver option LAMP방식으로 돌아가는 php에게 지속연결은 얼마나 큰 이점을 가져다 주는걸까요? 또한 결점은 무엇일까요? 1. mysql_pconnect가 커넥션 리소스를 유지하는 방법 Note: Note, that these kind of links only work if you are using a module version of PHP. See the Persistent Database Connections section for more information. mysql_pconnect는 PHP가 Apache의 모듈방식으로 작동할때만 사용할 수 있다고 합니다. 왜일까요? 이것은 모듈방식으로 돌아갈때 php는 Apache의 프로세스 내부에서 돌아가기 때문입니다. 그리고 Apache프로세스는 요청을 한번만 처리하는게 아니고 여러번 처리하게 됩니다. 몇번 처리할지는 Apache설정의 MaxRequestPerChild값을 따라갑니다. 결국 php가 관리한다고 하기보다 Apache에서 커넥션 리소스를 관리하고 있다고 보면 됩니다. Warning Using persistent connections can require a bit of tuning of your Apache and MySQL configurations to ensure that you do not exceed the number of connections allowed by MySQL. 또한 지속연결으로 인해 mysql 커넥션 최대치 설정과 apache 프로세스 최대치 설정의 튜닝이 필요합니다. 왜냐하면 아파치 프로세스의 최대치는 100인데 mysql 커넥션의 최대치는 90이라면 91번째 요청부터는 two many connections 오류가 날 수 있기 때문입니다. mysql_pconnect는 php에서 수동으로 커넥션을 끊을 수 없으며 mysql에서 waittime_out을 통해 일정시간 활동이 없는 리소스를 자동으로 kill하는 방식으로만 끊을 수 있습니다. 2. php내부 mysql_pconnect의 구현상세mysql_pconnect의 파라미터를 보면 다음과 같습니다. mysql_pconnect ([ string $server = ini_get(“mysql.default_host”) [, string $username = ini_get(“mysql.default_user”) [, string $password = ini_get(“mysql.default_password”) [, int $client_flags = 0 ]]]] ) : resource 순서대로 호스트, 사용자 아이디, 사용자 비밀번호, 설정 플래그 입니다. 이것만 가지고 어떻게 지속 연결 리소스를 공유할 수 있을까요? Apache와 php의 연동 동작방식에 대한 이해가 먼저 필요합니다. LAMP구조의 서버는 Centos, Apache, PHP, MariaDB을 이용하여 웹 서비스를 진행하고 있습니다. 먼저 Apache와 php가 어떻게 연동하여 동작하는지 간단하게 알아봅시다. Apache는 prefork라는 모드로 돌아가고 있으며 Apache를 시작하면 설정파일에서 설정해놓은 숫자만큼의 프로세스를 미리 생성해놓습니다. 해당 프로세스들은 생성할때부터 php를 Load하며 MINIT단계의 초기화까지 진행하고 사용자의 요청이 올때까지 기다립니다. (php는 MINIT, RINIT, RSHUTDOWN, MSHUTDOWN의 실행단계를 거칩니다.) 여기서 알아야 할 점은 모든 Apache 프로세스에서 돌아가는 PHP는 독립적이며 서로 어떠한 간섭도 없다는 것입니다. httpd-mpm.conf 파일 StartServers 5 MinSpareServers 5 MaxSpareServers 10 MaxClients 150 MaxRequestsPerChild 10 HTTP 요청이 들어오고 특정 Apache프로세스가 요청을 처리하기 시작합니다. php는 모든 처리를 마친다음 결과를 리턴해주며 최종적으로 Apache가 결과를 요청자한테 돌려보냅니다. 여기서 주의해야 할점, Apache 프로세스는 처리를 끝마쳤지만 종료하지 않고 다음 요청을 기다립니다. 즉 하나의 Apache프로세스는 하나의 요청만 처리하는게 아니고 여러번의 프로세스를 처리합니다. 따라서 Apache내부의 PHP도 여러번의 요청을 처리하게 되죠. 몇번의 요청을 처리하는가에 대한 설정값은 MaxRequestsPerChild의 값을 따라갑니다. mysql_pconnect를 통해 생성된 db커넥션은 바로 해당 프로세스에서 상주하게 되는 것입니다. 프로세스가 MaxRequestsPerChild번 만큼의 요청을 처리하고 종료될까지는. mysql_pconnect함수는 매번 실행될 때 먼저 db커넥션이 이미 존재하는지 체크하며 존재하면 가져와서 쓰고 존재안하면 db커넥션을 생성하고 메모리에 상주시킵니다. mysql에서는 그러면 이러한 커넥션을 어떻게 처리할까요? 답은 wait_timeout입니다. mysql은 주동적으로 해당 커넥션을 끊지 않고 wait_timeout에 설정한 값에 따라 특정 커넥션이 지정된 시간동안 활동이 없으면 종료시킵니다. 만약 Apache의 프로세스가 MaxRequestsPerChild만큼의 요청을 처리하고 종료되더라도 커넥션은 wait_timeout이 되야 종료됩니다. 3. mysql_pconnect의 문제점여기까지만 보았을때 큰 문제가 없어보이는게 사실입니다. mysql_pconnect에 대해 사람들이 언급하고 있는 주의점에 대해 알아보면 Apache의 child process의 합은 mysql server의 커넥션 허용갯수보다 많으면 안된다는 것입니다. too many connections오류를 방지하기 위해서입니다. 특정 Apache의 child process에서 mysql table에 lock을 걸고 커리를 수행하는 도중 예기치 못한 종료가 발생하면 pconnect때문에 커넥션을 유지하기 때문에 해당 테이블은 커넥션이 kill되기 전에는 lock상태를 유지하게 되며 서비스 장애로 이어지게 됩니다. 서비스의 방문자가 지속적으로 많지 않고 특정시간때에만 몰린다고 가정할때 Apache는 많은 child process를 생성하게 되고 커넥션을 많이 생성하게 되지만 방문자가 갑자기 사라질때 추가로 생성한 커넥션들은 kill당하기만 기다리는 리소스가 되어버리므로 위험부담이 있습니다. 4. 총결그렇다면 mysql_pconnect을 사용하지 않는게 좋을가요? 해당 함수를 사용하는데 대해 php.net에는 이렇게 소개하는 코멘트가 있습니다. This function is designed for environments which have a high overhead to connecting to the database. high overhead, DB에 연결하기 위해 많은 리소스와 시간이 필요될 때 사용하라고 권장합니다. 운영중인 웹 서버와 php5는 DB에 연결을 시도할 때 얼마만큼의 소모가 발생할까요? 또한 pconnect의 사용여부에 따라 얼마만큼의 위험부담과 반응속도의 문제가 있을지? mysql_connect와 mysql_pconnect중 어떤걸 사용할지에 대해서는 전반적인 성능측정과 튜닝이 필요하다고 생각됩니다. mysql_connect함수가 소모하는 CPUtime, TCP connection을 맺는데 사용하는 시간 mysql_pconnect의 리스크 범위 Apache설정과 mysql server의 설정값 튜닝","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://songxue77.github.io/tags/php/"}]},{"title":"new post","slug":"new-post","date":"2020-07-27T11:58:02.000Z","updated":"2020-07-27T11:58:02.841Z","comments":true,"path":"2020/07/27/new-post/","link":"","permalink":"http://songxue77.github.io/2020/07/27/new-post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-07-27T11:47:17.338Z","updated":"2020-07-27T11:47:17.338Z","comments":true,"path":"2020/07/27/hello-world/","link":"","permalink":"http://songxue77.github.io/2020/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://songxue77.github.io/tags/php/"}]}